###### BFS는 큐(Queue)를 이용하여 최단 경로, 네트워크 탐색, 웹 크롤링 등에 활용되는 너비 우선 탐색 알고리즘입니다. 🚀

# 🌐 너비 우선 탐색(BFS)

## 📌 그래프 탐색이란?

**그래프 탐색(Graph Traversal)** 은 **하나의 노드에서 시작하여 모든 노드를 한 번씩 방문하는 과정**입니다.  
그래프 탐색에는 대표적으로 다음과 같은 두 가지 방식이 있습니다.

1. **너비 우선 탐색(BFS, Breadth-First Search)**
   - 가까운 노드부터 탐색하는 방식
2. **깊이 우선 탐색(DFS, Depth-First Search)**
   - 한 경로를 따라 끝까지 탐색한 후 다시 돌아와 탐색하는 방식

---

## 🔹 너비 우선 탐색(BFS)이란?

**너비 우선 탐색(BFS)** 은 **임의의 노드에서 시작하여 인접한 노드를 먼저 탐색하는 방법**입니다.  
즉, **시작 노드에서 가장 가까운 노드를 먼저 방문하고, 가장 먼 노드를 나중에 방문하는 방식**입니다.

### ✅ BFS의 활용

- **최단 경로 찾기**
  - 두 노드 간의 최단 경로를 찾을 때 유용합니다.
- **네트워크 연결 탐색**
  - 그래프에서 특정 노드와 연결된 모든 노드를 탐색하는 데 적합합니다.
- **웹 크롤링**
  - 특정 페이지에서 가까운 링크부터 먼저 방문하는 방식으로 사용됩니다.

---

## 🛠️ BFS의 동작 방식

BFS는 **큐(Queue, 선입선출 구조)** 를 사용하여 다음과 같은 방식으로 탐색을 진행합니다.

### 🎯 BFS의 특징

1. **시작 노드를 큐에 넣고 방문 표시를 한다.**
2. **큐에서 노드를 하나 꺼내고, 인접한 노드를 모두 방문한다.**
3. **방문하지 않은 노드는 큐에 추가하고 방문 여부를 체크한다.**
4. **큐가 빌 때까지 반복한다.**

### ✅ BFS 탐색 과정 예제

다음과 같은 그래프가 있다고 가정해봅시다.

```c
    1
   / \
  2   3
 / \   \
4   5   6
```

BFS를 수행하면 탐색 순서는 다음과 같습니다.

```c
1 → 2 → 3 → 4 → 5 → 6
```

각 단계를 큐와 함께 살펴보면 다음과 같습니다.

| 큐 상태     | 방문 노드 |
| ----------- | --------- |
| `[1]`       | `1`       |
| `[2, 3]`    | `2`       |
| `[3, 4, 5]` | `3`       |
| `[4, 5, 6]` | `4`       |
| `[5, 6]`    | `5`       |
| `[6]`       | `6`       |

---

## 🚀 BFS 문제 예제

프로그래머스 **"가장 먼 노드"** 문제를 BFS로 해결하는 코드입니다.

```js
function solution(n, edge) {
  return bfs(1, edge, n);
}

const bfs = (start, array, end) => {
  const visited = new Array(end + 1).fill(false); // 방문 여부를 저장하는 배열
  const distance = new Array(end + 1).fill(0); // 각 노드까지의 거리 저장
  const queue = [start]; // BFS 탐색을 위한 큐

  visited[start] = true; // 시작 노드를 방문 처리

  while (queue.length) {
    const head = queue.shift(); // 큐에서 첫 번째 노드 꺼내기
    const dis = distance[head] + 1; // 현재 노드까지의 거리 +1

    for (const node of array) {
      if (node[0] === head && !visited[node[1]]) {
        queue.push(node[1]);
        visited[node[1]] = true;
        distance[node[1]] = dis;
      } else if (node[1] === head && !visited[node[0]]) {
        queue.push(node[0]);
        visited[node[0]] = true;
        distance[node[0]] = dis;
      }
    }
  }

  const maxDistance = Math.max(...distance); // 가장 먼 거리 찾기
  return distance.filter(num => num === maxDistance).length; // 가장 먼 노드 개수 반환
};
```

---

## 📌 코드 설명

1. **`visited` 배열**
   - 방문 여부를 기록하는 배열입니다.
2. **`distance` 배열**
   - 각 노드까지의 최단 거리를 저장합니다.
3. **`queue` 사용 (FIFO 구조)**
   - BFS 탐색을 위한 큐입니다.
4. **큐가 빌 때까지 반복**
   - 큐에서 노드를 꺼내고 인접 노드를 방문하며 탐색을 진행합니다.
5. **최대 거리 계산**
   - 가장 먼 거리를 찾아 해당 거리의 노드 개수를 반환합니다.

---

## 🏁 마무리

- **BFS는 최단 경로를 찾기에 유용한 알고리즘**입니다.
- **큐(Queue)를 이용하여 너비 우선으로 탐색**하며, 방문 여부를 체크해야 합니다.
- **방문 여부를 체크하지 않으면 무한 루프에 빠질 수 있음**을 주의해야 합니다.

실제 문제를 풀 때 **최단 거리, 네트워크 탐색, 웹 크롤링** 등의 상황에서 BFS를 활용할 수 있습니다! 🚀
